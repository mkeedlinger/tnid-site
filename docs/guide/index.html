<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Guide - TNID</title>
  <meta name="description" content="Type-safe, named, unique identifiers">
  <link rel="stylesheet" href="/css/pico.min.css">
  <link rel="stylesheet" href="/css/custom.css">
  
</head>
<body>
  <header class="container">
    <nav>
      <ul>
        <li><a href="/"><strong>TNID</strong></a></li>
      </ul>
      <ul>
        <li><a href="/guide/">Guide</a></li>
        <li><a href="/implementations/">Implementations</a></li>
        <li><a href="/playground/">Playground</a></li>
        <li><a href="https://github.com/mkeedlinger/tnid" target="_blank">Spec</a></li>
      </ul>
    </nav>
  </header>

  <main class="container">
    
<h1>Guide</h1>

<section>
  <h2>What is a TNID?</h2>
  <p>
    A TNID (Typed Named ID) is a unique identifier that includes a human-readable type name.
    Instead of seeing <code>d6157329-4640-8e30-8012-3456789abcde</code> in your logs or database,
    you see <code>user.Br2flcNDfF6LYICnT</code> and immediately know it's a user ID.
  </p>
</section>

<section>
  <h2>Why TNIDs?</h2>
  <p>Benefits over plain UUIDs:</p>
  <ul>
    <li><strong>Human-readable</strong> &mdash; IDs show their type in logs, URLs, and errors &mdash; no cross-referencing needed</li>
    <li><strong>Type-safe</strong> &mdash; Compile-time prevention of mixing up different ID types</li>
    <li><strong>Unambiguous</strong> &mdash; One canonical string representation per ID (UUID hex is case-insensitive)</li>
    <li><strong>Sortable</strong> &mdash; TNID strings sort correctly as plain strings</li>
    <li><strong>URL-safe</strong> &mdash; Uses only unreserved characters; no percent-encoding needed</li>
    <li><strong>Time-ordered option</strong> &mdash; V0 gives chronological sorting (like UUIDv7)</li>
    <li><strong>Random option</strong> &mdash; V1 gives full randomness (like UUIDv4)</li>
    <li><strong>UUID-compatible</strong> &mdash; Stores in UUID columns, works with existing tooling</li>
    <li><strong>Same size</strong> &mdash; Still 128 bits, no storage overhead</li>
    <li><strong>Encryption extension</strong> &mdash; Convert V0 to V1 to hide timestamps from clients</li>
  </ul>
</section>

<section>
  <h2>Two Formats, Same ID</h2>
  <p>Every TNID can be represented in two string formats:</p>

  <article>
    <header><strong>TNID Format</strong></header>
    <pre><code>user.Br2flcNDfF6LYICnT</code></pre>
    <p>Human-readable. Use in logs, URLs, APIs, and anywhere humans might see it.</p>
  </article>

  <article>
    <header><strong>UUID Format</strong></header>
    <pre><code>d6157329-4640-8e30-8012-3456789abcde</code></pre>
    <p>Standard format. Use with existing UUID tooling and libraries that expect this format.</p>
  </article>

  <p>These are the <em>same 128 bits</em> &mdash; convert freely between them. Store as a string (either format) or as binary (UUID/u128 columns).</p>
</section>

<section>
  <h2>Choosing a Name</h2>
  <p>The name is the type prefix (e.g., <code>user</code> in <code>user.Br2flcNDfF6LYICnT</code>).</p>

  <p><strong>Rules:</strong></p>
  <ul>
    <li>1-4 characters long</li>
    <li>Lowercase letters <code>a-z</code> and digits <code>0-4</code> only</li>
  </ul>

  <p><strong>Examples:</strong></p>
  <ul>
    <li><code>user</code>, <code>post</code>, <code>item</code>, <code>org</code></li>
    <li><code>tx</code>, <code>evt</code>, <code>req</code>, <code>job</code></li>
    <li><code>a</code>, <code>b1</code>, <code>c2d</code></li>
  </ul>

</section>

<section>
  <h2>Variants</h2>
  <p>TNIDs have a 2-bit variant field, allowing 4 variants:</p>

  <div class="grid">
    <article>
      <header><strong>V0 (Time-ordered)</strong></header>
      <p>Like UUIDv7: contains a millisecond timestamp. IDs sort chronologically.</p>
      <p><strong>Use when:</strong> You want to sort by creation time.</p>
    </article>
    <article>
      <header><strong>V1 (Random)</strong></header>
      <p>Like UUIDv4: 100 bits of random entropy. Maximum unpredictability.</p>
      <p><strong>Use when:</strong> You don't need chronological sorting.</p>
    </article>
  </div>

  <p><strong>V2</strong> and <strong>V3</strong> are reserved for future use.</p>

  <p>When in doubt, use V0. Time-ordering is usually helpful.</p>
</section>

<section>
  <h2>Type Safety</h2>
  <p>
    In languages that support it, the type system prevents mixing different TNID types.
    This catches bugs at compile time:
  </p>

  <pre><code>const userId: UserId = UserId.new_v0();
const postId: PostId = PostId.new_v0();

getUser(userId);  // OK
getUser(postId);  // Compile error!</code></pre>

  <p>
    The compiler catches the bug before your code runs.
    No more accidentally passing a post ID to a user lookup.
  </p>
</section>

<section>
  <h2>Quick Example</h2>

  <h3>TypeScript</h3>
  <pre><code>import { Tnid, TnidType } from "@tnid/core";

// Define your ID type
const UserId = Tnid("user");
type UserId = TnidType&lt;typeof UserId&gt;;

// Generate IDs
const id: UserId = UserId.new_v0();
console.log(id);  // "user.Br2flcNDfF6LYICnT"

// Convert to UUID for database storage
const uuid = UserId.toUuidString(id);
// "d6157329-4640-8e30-8012-3456789abcde"

// Parse from string
const parsed = UserId.parse("user.Br2flcNDfF6LYICnT");</code></pre>

  <h3>Rust</h3>
  <pre><code>use tnid::Tnid;

// Define your ID type
type UserId = Tnid&lt;"user"&gt;;

// Generate IDs
let id: UserId = UserId::new_v0();
println!("{}", id);  // "user.Br2flcNDfF6LYICnT"

// Convert to UUID
let uuid = id.to_uuid();

// Parse from string
let parsed: UserId = "user.Br2flcNDfF6LYICnT".parse()?;</code></pre>
</section>

<section>
  <p><a href="/implementations/">See all implementations &rarr;</a></p>
</section>

  </main>

  <footer class="container">
    <small>MIT License</small>
  </footer>

  <script type="module" src="/js/playground.js"></script>
</body>
</html>
